// Copyright 2024-2025 Irreducible Inc.

//! Example of a Binius SNARK that proves execution of Poseidonb permutations.

use std::array;

use anyhow::Result;
use binius_core::{oracle::OracleId, transparent::constant::Constant};
use binius_field::{BinaryField32b, Field, PackedField, TowerField};
use binius_math::{ArithCircuit, ArithExpr};

use crate::builder::{ConstraintSystemBuilder, types::F};

type B32 = BinaryField32b;
const P_ROUNDS: usize = 15;
const F_ROUNDS: usize = 8;
const N_ROUNDS: usize = F_ROUNDS + P_ROUNDS;

const STATE_SIZE: usize = 24;

fn plain_permutation(state: &mut [BinaryField32b; STATE_SIZE], n_rounds: usize) {
	// initial mds matrix mult
	let mds_input = state.clone();
	for i in 0..state.len() {
		// mds matrix mult
		let mut mds_out_curr = B32::ZERO;
		for j in 0..STATE_SIZE {
			mds_out_curr += BinaryField32b::new(MDS_FULL[i][j] as u32) * mds_input[j];
		}
		state[i] = mds_out_curr;
	}

	//full and partial rounds
	for r in 0..n_rounds {
		if r < F_ROUNDS / 2 || r >= F_ROUNDS / 2 + P_ROUNDS {
			//  Full (external) rounds
			for i in 0..state.len() {
				//rc add
				state[i] = state[i] + BinaryField32b::new(RC[i][r]);
			}
			for i in 0..state.len() {
				//sbox
				state[i] = state[i].pow(7);
			}
			let mds_input = state.clone();
			for i in 0..state.len() {
				// mds matrix mult
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_FULL[i][j] as u32) * mds_input[j];
				}
				state[i] = mds_out_curr;
			}

		} else {
			//  Partial (internal) rounds
			//rc add
			state[0] = state[0] + BinaryField32b::new(RC[0][r]);
			//sbox
			state[0] = state[0].pow(7);
			// mds matrix mult
			let mds_input = state.clone();
			for i in 0..state.len() {
				// mds matrix mult
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_PARTIAL[i][j] as u32) * mds_input[j];
				}
				state[i] = mds_out_curr;
			}
		}
	}
}

pub fn permutation(
	builder: &mut ConstraintSystemBuilder,
	log_size: usize,
	p_in: [OracleId; STATE_SIZE],
) -> Result<[OracleId; STATE_SIZE]> {
	println!("Number of rounds: {}", F_ROUNDS + P_ROUNDS);
	let round_0_input: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("mds_out_full_{}", row),
				log_size,
				MDS_FULL[row]
					.iter()
					.enumerate()
					.map(|(i, &elem)| (p_in[i], F::from(BinaryField32b::from(elem as u32)))),
			)
			.unwrap()
	});

	if let Some(witness) = builder.witness() {
		let perm_in_data_owned: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(p_in[i]))?;
		let perm_in_data: [_; STATE_SIZE] = perm_in_data_owned.map(|elem| elem.as_slice::<B32>());
		let mut round_0_input_data: [_; STATE_SIZE] =
			round_0_input.map(|id| witness.new_column::<B32>(id));
		let round_0_input_32b = round_0_input_data
			.each_mut()
			.map(|elem| elem.as_mut_slice::<B32>());

		for z in 0..1 << log_size {
			for i in 0..STATE_SIZE {
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_FULL[i][j] as u32) * perm_in_data[j][z];
				}
				round_0_input_32b[i][z] = mds_out_curr;
			}
		}
	}

	let full_0_out = (0..F_ROUNDS / 2).try_fold(round_0_input, |state, round_i| {
		full_round(builder, log_size, round_i, state, RC)
	})?;

	let partial_out = (F_ROUNDS / 2..(F_ROUNDS / 2 + P_ROUNDS))
		.try_fold(full_0_out, |state, round_i| {
			partial_round(builder, log_size, round_i, state, RC)
		})?;

	let perm_out = (F_ROUNDS / 2 + P_ROUNDS..N_ROUNDS)
		.try_fold(partial_out, |state, round_i| {
			full_round(builder, log_size, round_i, state, RC)
		})?;

	#[cfg(debug_assertions)]
	if let Some(witness) = builder.witness() {
		let p_in_data: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(p_in[i])).unwrap();
		let p_in_32b: [_; STATE_SIZE] = p_in_data.map(|elem| elem.as_slice::<B32>());
		let p_out_data: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(perm_out[i])).unwrap();
		let p_out_32b: [_; STATE_SIZE] = p_out_data.map(|elem| elem.as_slice::<B32>());
		for z in 0..1 << log_size {
			let expected_out: [B32; STATE_SIZE] = array::from_fn(|s| p_out_32b[s][z]);
			let mut state_in: [BinaryField32b; STATE_SIZE] =
				std::array::from_fn(|i| p_in_32b[i][z]);
			plain_permutation(&mut state_in, N_ROUNDS);
			assert_eq!(state_in, expected_out);
		}
	}
	Ok(perm_out)
}

#[rustfmt::skip]
const RC: [[u32; N_ROUNDS]; STATE_SIZE] = [
[0x771072, 0x51319c, 0x61e675, 0x79eca2, 0x7f2080, 0x1af9d4, 0x54b3b4, 0x21e60a, 0xc37ac, 0x38b909, 0x1b188f, 0x205576, 0x479b01, 0x52bc4, 0x3dabbc, 0x6e6d88, 0x3945be, 0x671d8c, 0xfb4b6, 0x399d5, 0x13d5be, 0x6a63e2, 0x228c88, ],
[0x2e8857, 0x35735b, 0x320e8a, 0x419427, 0x292454, 0x4d52e1, 0x8c04c, 0x74e743, 0x2c8d01, 0x575a4c, 0x7cf391, 0x504583, 0x3a5600, 0x36b21b, 0x784c52, 0x7605f5, 0x1caf99, 0x28a37e, 0x6d32dd, 0x2475dd, 0x3cbded, 0x27461f, 0x66b33f, ],
[0x39966f, 0x58182d, 0x672900, 0x39dcab, 0x1d2d81, 0x35bec1, 0x662652, 0x35e41e, 0x1401f0, 0x798120, 0x5cc27f, 0x582445, 0x5d505e, 0x637dd2, 0x2cbfa2, 0x62b888, 0x315328, 0x329ae2, 0x63e7fe, 0x6b94f7, 0x6c78bc, 0x5ad340, 0x36051b, ],
[0x31fa1d, 0x1a9cae, 0x11fe38, 0x4091b8, 0x248a8a, 0x5a2674, 0x230087, 0x10975, 0x1c7477, 0xfb343, 0x49fdec, 0x38daec, 0x128f92, 0x761134, 0x1fbc34, 0x6da59, 0x4f5397, 0x1d154, 0x1de920, 0x629d31, 0x2524f3, 0x3c2963, 0x2c01d6, ],
[0x624540, 0x74e4d9, 0x523c77, 0x14e0d7, 0x6738ac, 0x430e9b, 0x1f0077, 0x36e0d6, 0x7a4438, 0x654941, 0x5c7ab0, 0x4a8a1c, 0x1e0661, 0x4106b, 0x2d9fec, 0x455411, 0x16e537, 0x7a046b, 0x587ed5, 0x1a35b7, 0x3b2192, 0x56a661, 0x5f10c5, ],
[0x318676, 0xc42b9, 0x7b4acc, 0x4b07b5, 0x6ecab2, 0xb4920, 0x5de07d, 0x1cae35, 0x45791d, 0x4de1a6, 0x73f410, 0x452670, 0x2a06e0, 0x250194, 0x373259, 0x26e872, 0x3afe98, 0x4dc608, 0x28f593, 0x22d69c, 0x5c9620, 0x19f629, 0x14398a, ],
[0x3d7a3c, 0x52795d, 0x7d37c7, 0x612312, 0x4af7b9, 0x41098c, 0x369a73, 0x4e85d5, 0x3f9303, 0x7d6a75, 0x43ceda, 0x4b15c7, 0x62cb2d, 0x7ead89, 0x56596, 0x40db2b, 0x7b4ec6, 0x3c08, 0x48cde7, 0x1688b5, 0x14bcff, 0xb727b, 0x19ac3f, ],
[0x596c14, 0x53689d, 0x73eb46, 0x2cb502, 0x3746c1, 0x14ae34, 0x43d352, 0x62f59c, 0x591fda, 0x12017d, 0x3a6555, 0x1ee38, 0x4b3201, 0x18ca52, 0x199c87, 0xaf68c, 0x73d045, 0x50175a, 0x207bbb, 0x426439, 0x5d1b29, 0x6dd16d, 0x459ff0, ],
[0x59159d, 0xa2f0, 0x616eb, 0x4c3c0b, 0x483085, 0xf5c83, 0x25e103, 0x405013, 0x5137e1, 0x244dfa, 0x11e8f8, 0x6bb6e4, 0x31fbcc, 0x5746ad, 0x22bd02, 0x4679d9, 0x5f20c9, 0x50ac25, 0xb5750, 0x77b1de, 0xf72c2, 0x746ae8, 0x1b3ac8, ],
[0xeb930, 0x7cee5c, 0x5e1d3b, 0x3e8b80, 0x68093b, 0x219962, 0x21a5cb, 0x6ae008, 0x1a5ef, 0x4cdd1e, 0x7ae73e, 0x6a0626, 0x57ba85, 0x1bd490, 0xe0150, 0x2a3755, 0x39d6c8, 0x68461e, 0x2add5c, 0xf1ae, 0x4318fc, 0x4ff0f6, 0xb5d62, ],
[0x7478e9, 0x45ef43, 0x37b36, 0x29bc0d, 0x84b78, 0x5c6ed8, 0x22d655, 0x7b8442, 0x443d5b, 0x64744, 0x5f3e0a, 0x737ca9, 0x19f8b2, 0x2db017, 0x47a56f, 0x6f78dd, 0x65890b, 0x9aa90, 0x24ef47, 0x9daff, 0x498b8e, 0xd1790, 0x2b7ee3, ],
[0x14805a, 0xa749a, 0x1676cc, 0x225cab, 0x59e068, 0x65ef5b, 0x22c412, 0x70f07e, 0x1585fd, 0x6b613d, 0x1da074, 0x6ef5ee, 0x7f2157, 0x4d493e, 0x1f9c6c, 0x18f7c8, 0x5db4a4, 0x126b0b, 0x7382a1, 0x1f3995, 0x5ac22e, 0x39bd24, 0x6a6256, ],
[0x701ecc, 0x770466, 0x2c9c27, 0x3d41f5, 0x5061da, 0x3d1039, 0x21b3a0, 0x500b79, 0x585439, 0x5b352d, 0x102af, 0x6ac77e, 0x8f5e1, 0x34afb, 0x42cc70, 0x33e5cd, 0x1c0a75, 0x3bc130, 0x186f54, 0x75583, 0x7a8e79, 0x66a2e5, 0xd547d, ],
[0x59e9c4, 0x201f9f, 0x4cb8d1, 0xf8253, 0x729e0c, 0x68d9, 0xa8c23, 0x24d4f0, 0x48f9aa, 0x5fa016, 0x174ab3, 0x7389ed, 0x63f1fb, 0x391f75, 0x7acc23, 0x6d0a05, 0x1aa24, 0x39fd32, 0x2f2a13, 0x608635, 0x69c5a2, 0x76f6c0, 0x6358cf, ],
[0x7b789c, 0x2df049, 0x1587a5, 0x69950b, 0xe3576, 0x123fa0, 0x2f0b73, 0x3581d5, 0x12c0a2, 0x1fe1f3, 0x777835, 0x534b47, 0xa336e, 0x3afdef, 0x2ec11e, 0x2df976, 0x12fd43, 0x1f22be, 0x3608aa, 0x71e07c, 0x48b2bb, 0x7f0e48, 0x1ee56a, ],
[0x4eb6d9, 0x32ac4c, 0x467fa9, 0xa58e6, 0x2bfd95, 0x7e463a, 0x1f6732, 0x28ed9, 0x6c3064, 0x57ed6, 0x30c6b, 0x34755d, 0x58d149, 0x705da9, 0x37e42d, 0x7a4ed7, 0x2fa687, 0x2a1033, 0x2ed72, 0x566460, 0x29e787, 0x3efec4, 0x1aafa8, ],
[0x4015ba, 0x3612b3, 0x20f95b, 0x2e823, 0x5ba72e, 0x1b8d91, 0xad94, 0x7862da, 0xcd6f3, 0x14c42f, 0x1ff03a, 0x2d9e57, 0x73336a, 0x665582, 0x21ed70, 0x153232, 0x54b143, 0x7ed7ff, 0x601779, 0x5f3c2d, 0x21a3bf, 0x2fb4c3, 0x364a2b, ],
[0x7288be, 0x7c0dbd, 0x28f96d, 0x852f9, 0x4e8580, 0x4781a2, 0x70a0bc, 0x671b19, 0x555c9f, 0x4a2fc3, 0xe8e02, 0xae166, 0x338a37, 0x22680, 0x24c1a5, 0x35375e, 0x29ddcc, 0x43b613, 0x1e8972, 0x7d11da, 0x6199cb, 0x359efc, 0x20cb5b, ],
[0x454a86, 0x5a1d17, 0x755183, 0x25343d, 0x581a86, 0x76549e, 0x49dc, 0x68b534, 0x276b31, 0x526064, 0xce703, 0x1b99e8, 0x488e0e, 0x3eb53c, 0x2ddbf4, 0x3a6e0, 0x211e6f, 0x721282, 0x644b2a, 0x6a640c, 0x6590c7, 0x29473c, 0x5073eb, ],
[0x6c1fb6, 0x357cc, 0x4a6618, 0x42f6cc, 0x19d215, 0x7302b9, 0x47f449, 0x2cabc2, 0x5a9a86, 0xe1a91, 0x280314, 0x1231db, 0x39b471, 0x19e1ab, 0x6e7bf, 0x3dd737, 0x7be63d, 0x1f9219, 0x76d34, 0x5cdf45, 0x1d698e, 0x4ec59, 0x4a6a31, ],
[0x5b938b, 0xc1593, 0x7f23f7, 0x58bce, 0x6bae1c, 0x2816f2, 0x45f1c7, 0x3c6eef, 0x364434, 0x445663, 0x287e7, 0x40f409, 0x5f250e, 0x698e7e, 0x6dd260, 0x38fbef, 0xd9ff3, 0x4946e5, 0x4e3569, 0xacaf6, 0x2b2863, 0xfd7c2, 0x468858, ],
[0x33bb85, 0x7d8109, 0x4cfa87, 0x2a02f0, 0x4cdd22, 0x468e0, 0x7cd100, 0x12a411, 0x247108, 0x622800, 0x5dc557, 0x7349f8, 0x396518, 0x2770d, 0x2cf48c, 0x38938f, 0x6346a0, 0x1ea050, 0x708bdd, 0x6450ef, 0x5aee41, 0x55cabd, 0x373aa6, ],
[0x51b823, 0x4ec20a, 0x2dd5f3, 0xbd69f, 0xbbadd, 0x5bc123, 0x3a0ae2, 0x206092, 0x64c5ef, 0x7b18be, 0x32a87b, 0x78fd18, 0x595ad9, 0x503d85, 0xe4f5a, 0x42808f, 0x4eeae8, 0xbbf47, 0x7a4c80, 0xc93be, 0x11b4b9, 0x214a2a, 0x51c73a, ],
[0x361563, 0x136780, 0x79a425, 0x13820c, 0xcb4c5, 0x7eb003, 0x68896, 0x7a4c30, 0x5c4eef, 0x1abe33, 0x563066, 0x5e850b, 0x2f6c7b, 0x7517cf, 0x52b91f, 0x70a4b3, 0x371854, 0x2c6a8b, 0x311f82, 0x7041d7, 0xf2223, 0x18ff88, 0x58245a, ],
];

pub const MDS_FULL: [[u32; STATE_SIZE]; STATE_SIZE] = [
[0xadec244c,0x6442245b,0x33f0a6ca,0x4becc716,0x88869a11,0x6308f3e7,0x9af00334,0xa50ad268,0xb78e1f64,0x5d09dbf9,0x0b117f31,0x391f393a,0x54d2bdf1,0x7d21b67f,0xb58c2826,0x0f9802d1,0x63c9c7db,0xa81f7ede,0xa184a4bb,0xe1a6a19f,0xae9db001,0x94563156,0x6acc49c5,0x0d2341de],
[0xbfb66ebc,0x9cc4e972,0x401b234a,0xe4eb0ac8,0x916a4318,0xd4e3e379,0xf3ec41ab,0xf9819e6c,0x2476964c,0x6fe1b8a4,0x21edc3e9,0x59c75bf8,0x7400b06c,0x3aa9df7a,0x7ffd1e75,0x144f3854,0xb7dca355,0x39986791,0x6409b6a8,0x40c4a253,0x169c6cb8,0xe3b1329f,0x58214943,0xe2f85d30],
[0x3971907d,0x32766568,0xe01f523c,0xc3104b9f,0x2eac693c,0x6dfe764f,0x68805dae,0x4eedbc7d,0x907cc479,0x19e77063,0xf5d7301a,0x65a9d641,0xd1a8d8bc,0x5c5c4239,0x0b2e7842,0x6601c8a3,0x959a01d1,0xd488425c,0xc2352741,0x163e08aa,0x59f09740,0xd8d85cff,0x2a5d4a3f,0x2726bbc5],
[0xc694029c,0xae22d502,0x8cd8a807,0x204e23c8,0x50265268,0xd3d0c265,0x9e12356d,0xdb86c98e,0xd92f9a18,0x690f0415,0x14bc99dd,0x20924661,0x83c8f0b2,0xd06790ab,0x2a73b122,0x9ccd5ac0,0xdec0c396,0xbf6a216f,0xe542e6b9,0x107ba7ef,0xf7702b6c,0x9e2fb226,0x23722703,0x2f490719],
[0xc0af194d,0x8a355895,0xa19cd8b9,0x2cc84610,0x6909205f,0x22a28448,0xffdc6733,0x5e62d060,0xad270c1a,0xf5ccd56c,0xd5ceab5b,0xfaf685bc,0xf4fe3397,0xc3431064,0xcd0f516f,0x2e49b7a2,0x37af36bb,0x429e211e,0xdedfc4e3,0x0b51a75d,0x4c0aa45c,0xf7620d3b,0x9157f4cb,0xb7715fcb],
[0x3f342f8e,0x7cc999b0,0x8421d2a1,0xbb3fe230,0x59ed6304,0x9b15ad1a,0xa93b5f25,0x80f203b2,0x71527883,0xc7223a18,0x5ffbb1a8,0xc663f610,0x785ea964,0x956d78a2,0x23bd03ec,0xd628d1ba,0x9044f4d4,0x6037b26c,0xbc0f4ed1,0xe9e37580,0x2a84f394,0x460b6a32,0x5977d591,0x85bb9f49],
[0x5c6c9af9,0x1e4e57d4,0x33fdca01,0x6e081f83,0x9dcc1ece,0x2e6ec382,0x0404beb2,0x1a8ccc38,0x87a65857,0xbb4cfcf2,0xde427d0c,0x740db459,0x5fe73208,0x59a38d80,0x90159e97,0xb73c333e,0x748fd54f,0xeef903ca,0x67cf3536,0xca4c0492,0x26f78c98,0x656af2f2,0xc01ef8ec,0x37078d87],
[0x5d1d606c,0xa4360193,0x39757795,0x1609c010,0x4e480c38,0x1f10cb17,0x4c4e39da,0x220cd479,0x3bac1e22,0xa4c90ac7,0x8a687b69,0x3c652315,0xb8231b8c,0xd64bb1bb,0x676a4f40,0x679a4c3f,0x88e7da9d,0x65400718,0xce915737,0x0d5de2c0,0x2dfc0e42,0x86a7b904,0x82c8d4be,0x9cd99a18],
[0x14cb4757,0x9e0de617,0x221ea6e0,0xd1aa7c63,0xc5c6f557,0xac41a76b,0xe6aac76b,0x344f44c5,0xd559407b,0xc03abf0d,0xfaddf4cd,0x71696de6,0x4b6e89a6,0x8923749d,0x633b40cc,0xc19e9c26,0x82623ce3,0xe85fd71c,0xbe11c790,0x6fd73968,0x1c660492,0x5b10edfd,0xb8d52c4e,0x1f412775],
[0x0befb556,0x116c4d84,0x80f457ef,0x29b69550,0x2a7cee2f,0xeb00f43f,0x6cd45ae9,0x4747ee7f,0x453b3e41,0x65a5384e,0xe54cbfdf,0x44fc4771,0x81d5e344,0xa48382f0,0x3acd866b,0xa5eeb2cd,0x70b43a42,0x2c003dde,0xd1c6f787,0x36cfaa1c,0x8b59019d,0x70fac79e,0x62916b17,0xe1af1950],
[0xc8534c35,0xa3474c00,0xc077b343,0xd1c17b39,0x5af1395b,0x83ad08f3,0x2a59772e,0xe7cc9779,0x090d92b8,0x343db41f,0xb3d2131d,0xbb6c6f64,0x869bc02d,0x81155ae9,0xfd5a5325,0xcd9ec3b2,0x7384dd92,0x4bc2a44c,0xa87fcdc3,0x666e1599,0x85fa3574,0x5edd521e,0xc1f6ed8e,0x3d66e55b],
[0x18f1f657,0xb6093c79,0xd4f42211,0xaf3e7987,0xaf89deb5,0xde476b24,0x7f9dee01,0xdf772831,0x7f826333,0x1ced1700,0x8c8ac9c9,0x708342be,0x30aea4fb,0xfa36f10d,0xfde99c67,0xba4b1926,0xa2a3c827,0xbafafe63,0xa1c071f5,0xfc04cd2e,0x4c7dd693,0x1d5a70f1,0x13c4c224,0xfe55b4b5],
[0xf3164b35,0x945a9484,0xbf8aef65,0x4d7d4c67,0x28ac0038,0x836a3077,0xebc658ed,0x1a18157f,0xc3db20e4,0xabbcac35,0x3d8fa52b,0xc19016df,0x22e68ba8,0x198ae520,0x8878fb45,0x092bf06d,0x5a19356a,0x68b12205,0x5334314c,0xbc0ad794,0xbea09c79,0xf023311a,0x3a8dc04d,0xd39a6185],
[0x04702a7c,0x8c20521d,0x160c75b6,0x32a39007,0x39eec192,0x08cbed2a,0xa668c996,0x01a7f957,0x575a0515,0x4aecb28a,0xf4baa0e6,0x2f13fa74,0xaf2a50e9,0x47f530e9,0x843f591d,0x1c9eea07,0x9428a203,0x10e89cb5,0x6f46e7d7,0x61603530,0x5f5c026c,0x908484c0,0x0f6ac110,0x030d7fbe],
[0x57b17776,0x004cff59,0x52b7a625,0xa0a8fbee,0x8d5c97b4,0x0f256e49,0x1899bf1b,0xdd3211cc,0x03263783,0x8708afde,0x4260b9fb,0xe6d43d93,0x7483c843,0x63e1606f,0x20a5c747,0x817269c8,0xc0e2bf5f,0x523bb139,0xe6fe3f8a,0xa4353b32,0xd98827aa,0x1046cee2,0x7205ad88,0xc136dbce],
[0x5944993b,0x472e1c33,0x77f9b95e,0xdb7a4725,0x17dd7190,0x0418ba17,0x58840580,0x53c867ed,0x761d602a,0x2ecc052e,0xa9e12014,0x5fe49c0d,0x5118a682,0x021c29fb,0xb8d86371,0xbc39c50d,0x96a4a315,0x44afb287,0xbc966664,0xaadf6e78,0x874243d3,0x413c18c1,0x20a6e096,0x1598b2f9],
[0x10555b11,0x89920cd7,0xd295ab4a,0x74860ef5,0x0b20cf5d,0xac9f58dc,0x947fe190,0x0a82a46b,0x51349cef,0x42900cb7,0xc414df17,0x9de55594,0xbe40fe10,0x74d48507,0xaa88a1d7,0x5c801047,0x5c51628c,0x80d51d89,0x368d663a,0x6fd121dd,0xd22d9147,0xaf84b747,0x3c6b07a9,0x26dd2ef3],
[0x2b384086,0x2bfa02fd,0x5cbbffdb,0x6a81e888,0x324a9c26,0x338e2c74,0x2850943c,0xf332005d,0x26c06e99,0x7bc41671,0x449ef2d4,0x9ec6a1a5,0x84606cc1,0x243d5444,0x9c8839b1,0x1be26578,0xb4c66fda,0x09dd474d,0x8740c35f,0xf83a3cf3,0x9b08184e,0xb609032d,0x73b6eae4,0xe6772f96],
[0x0bc29ff0,0x2b7831c8,0xad034c4a,0xd110211d,0x47005b60,0xe5535562,0xcdc2eb42,0x08fed912,0xad947790,0x9dff82c4,0x6fb4def7,0x1a0055ab,0x6b92df23,0xa2c1055c,0xd62efa76,0x92847841,0xc3a39f8a,0x3e16b2fd,0xd7ce0441,0x21b67a77,0x03a2c015,0xe6cb6d81,0x65361767,0xb1dc114c],
[0xaf27cf8f,0x2d107443,0x0beaf3a1,0x870f8794,0x1f7d4a9c,0xc2aa16ef,0x5a5bf573,0x2063dcb3,0x9608e4ac,0xdf1f75e3,0xae826eba,0xafeec8f6,0x4aec98c6,0x08b13512,0xb8f73aea,0x362b0750,0xb3baad4f,0x407262d2,0x4b84241b,0x57933205,0x2c0d78df,0x0c0a82b1,0x80a4e648,0xd252d0ca],
[0x539357d0,0x5c4834d9,0x132bb5c6,0x679d56a4,0x8920970e,0xd13d4682,0xa6aef589,0x4d98bec1,0x386818f3,0x5ddbc3f4,0x8a6a1785,0x815f4829,0x63d4c855,0xd30905e5,0x7c16c499,0xed4e26c3,0x5fa37405,0xac230378,0x93408ece,0xa88269ef,0x7be2f2a0,0x9b36f5c7,0x28dbfef0,0xe362c400],
[0x016d46f1,0xfa256202,0x8cb0d3d0,0x20c72651,0xacfdd301,0xdb0d40f0,0xf238eec8,0x22e08a0d,0x6a7ae06b,0xd491ec1c,0xa11fcd9a,0x4e72dd36,0x630aa4cb,0xf936ebf4,0xe69d8b31,0x0eb1ad4b,0x1fbb0118,0xd53c563b,0xfb4787bd,0xe51ab938,0xe8565795,0x1b704c99,0x5bdb2bc2,0x07dea1cc],
[0x93ec8bb9,0xbae4ec06,0xa8ce3976,0x8fbeb1c4,0xa4ae6f60,0x15301bf8,0x3063e9ad,0x6609944b,0x95f76055,0xd793e2bb,0xdf90cdd0,0xce2b2ffd,0x4faacdb8,0xba6dcd10,0x7a18a347,0xc3dc043b,0x7d30723b,0x9b59f1c5,0x9ca000fa,0xcbbefcc3,0xcb8badd5,0xc43a5237,0x24c5ca28,0xa5882aa3],
[0x9d4bffcb,0x9e9ff811,0xcc417e07,0xf5fa8ccb,0xf3fdac2b,0xa6d2ceb4,0xe8231a5b,0x9b01eada,0xb3584c49,0x72cb94ae,0x708d4171,0x4d5707d5,0xaa13e8a4,0x8fa1b7a5,0xe18c361f,0x0292c2e6,0x7b730d1d,0x22566feb,0x68c7043f,0x9bef95f7,0x4874160d,0x49eccfef,0xb888bb9a,0x46455ab2],
];

#[rustfmt::skip]
const MDS_PARTIAL: [[u32; STATE_SIZE]; STATE_SIZE] = [
[0x881, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x4020, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x8100, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x8020, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1008, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x4008, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x402, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x108, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x4001, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1010, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x30, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1800, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x48, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1020, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x208, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x120, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x8400, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x880, 0x1, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x3, 0x1, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2002, 0x1, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0xa0, 0x1, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1004, 0x1, ],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x8200, ],
];

fn x7_constraint_expr<F: TowerField>() -> Result<ArithCircuit<F>> {
	let x = ArithExpr::Var(0);
	let x7 = ArithExpr::Var(1);

	let input_pow2 = x.clone().pow(2);
	let input_pow4 = input_pow2.clone().pow(2);
	let input_pow6 = input_pow2 * input_pow4;
	let input_pow7 = input_pow6 * x.clone();
	
	Ok((x7.clone() - input_pow7).into())
}

fn full_round(
	builder: &mut ConstraintSystemBuilder,
	log_size: usize,
	round_i: usize,
	state_in: [OracleId; STATE_SIZE],
	round_constants: [[u32; N_ROUNDS]; STATE_SIZE],
) -> Result<[OracleId; STATE_SIZE]>
where {
	builder.push_namespace(format!("full round[{round_i}]"));
	let full_round_consts: [OracleId; STATE_SIZE] = array::from_fn(|i| {
		builder
			.add_transparent(
				format!("full_round_const{}", i),
				Constant::new(log_size, BinaryField32b::new(round_constants[i][round_i])),
			)
			.unwrap()
	});

	let add_rc: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("add_rc_full_{}", row),
				log_size,
				[
					(state_in[row], Field::ONE),
					(full_round_consts[row], Field::ONE),
				],
			)
			.unwrap()
	});

	let s_box_out = builder.add_committed_multiple::<STATE_SIZE>(
		"sbox_out_full",
		log_size,
		BinaryField32b::TOWER_LEVEL,
	);

	let mds_out: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("mds_out_full_{}", row),
				log_size,
				MDS_FULL[row]
					.iter()
					.enumerate()
					.map(|(i, &elem)| (s_box_out[i], F::from(BinaryField32b::new(elem as u32)))),
			)
			.unwrap()
	});

	builder.pop_namespace();

	// Witness gen
	if let Some(witness) = builder.witness() {
		let state_in: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(state_in[i]))?;
		let state_in_u32: [_; STATE_SIZE] = state_in.map(|elem| elem.as_slice::<B32>());

		let mut full_round_consts = full_round_consts.map(|id| witness.new_column::<B32>(id));
		let full_round_consts_32b = full_round_consts
			.each_mut()
			.map(|elem| elem.as_mut_slice::<B32>());

		let mut add_rc = add_rc.map(|id| witness.new_column::<B32>(id));
		let add_rc_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			add_rc.each_mut().map(|elem| elem.as_mut_slice());

		let mut s_box_out = s_box_out.map(|id| witness.new_column::<B32>(id));
		let s_box_out_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			s_box_out.each_mut().map(|elem| elem.as_mut_slice());

		let mut mds_out = mds_out.map(|id| witness.new_column::<B32>(id));
		let mds_out_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			mds_out.each_mut().map(|elem| elem.as_mut_slice());

		// Fill in constants
		for i in 0..STATE_SIZE {
			full_round_consts_32b[i]
				.iter_mut()
				.for_each(|rc| *rc = BinaryField32b::new(round_constants[i][round_i]));
		}

		for z in 0..1 << log_size {
			for i in 0..STATE_SIZE {
				add_rc_32b[i][z] = state_in_u32[i][z] + full_round_consts_32b[i][z];
			}

			for i in 0..STATE_SIZE {
				s_box_out_32b[i][z] = add_rc_32b[i][z].pow(7);
			}

			for i in 0..STATE_SIZE {
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr +=
						BinaryField32b::new(MDS_FULL[i][j] as u32) * s_box_out_32b[j][z];
				}
				mds_out_32b[i][z] = mds_out_curr;
			}
		}
	}

	// zero check constraints
	for s in 0..STATE_SIZE {
		builder.assert_zero(format!("x7_{s}"), [add_rc[s], s_box_out[s]], x7_constraint_expr()?);
	}

	Ok(mds_out)
}

fn partial_round(
	builder: &mut ConstraintSystemBuilder,
	log_size: usize,
	round_i: usize,
	state_in: [OracleId; STATE_SIZE],
	round_constants: [[u32; N_ROUNDS]; STATE_SIZE],
) -> Result<[OracleId; STATE_SIZE]>
where {
	builder.push_namespace(format!("round[{round_i}]"));

	let partial_round_const: OracleId = builder
		.add_transparent(
			format!("partial_round_const{}", 0),
			Constant::new(log_size, BinaryField32b::new(round_constants[0][round_i])),
		)
		.unwrap();

	let add_rc: OracleId = builder
		.add_linear_combination(
			format!("add_rc_partial_0"),
			log_size,
			[(state_in[0], Field::ONE), (partial_round_const, Field::ONE)],
		)
		.unwrap();

	let s_box_out: OracleId =
		builder.add_committed("sbox_out_partial", log_size, BinaryField32b::TOWER_LEVEL);

	let mds_out: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("mds_out_partial_{}", row),
				log_size,
				MDS_PARTIAL[row].iter().enumerate().map(|(i, &elem)| {
					if i == 0 {
						(s_box_out, F::from(BinaryField32b::new(elem as u32)))
					} else {
						(state_in[i], F::from(BinaryField32b::new(elem as u32)))
					}
				}),
			)
			.unwrap()
	});

	builder.pop_namespace();

	type B32 = BinaryField32b;

	// Witness gen
	if let Some(witness) = builder.witness() {
		let state_in: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(state_in[i]))?;
		let state_in_u32: [_; STATE_SIZE] = state_in.map(|elem| elem.as_slice::<B32>());
		let mut partial_round_const = witness.new_column::<B32>(partial_round_const);
		let partial_round_const_32b = partial_round_const.as_mut_slice::<B32>();

		let mut add_rc = witness.new_column::<B32>(add_rc);
		let add_rc_32b: &mut [BinaryField32b] = add_rc.as_mut_slice();

		let mut s_box_out = witness.new_column::<B32>(s_box_out);
		let s_box_out_32b: &mut [BinaryField32b] = s_box_out.as_mut_slice();

		let mut mds_out = mds_out.map(|id| witness.new_column::<B32>(id));
		let mds_out_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			mds_out.each_mut().map(|elem| elem.as_mut_slice());

		// Fill in constants
		partial_round_const_32b
			.iter_mut()
			.for_each(|rc| *rc = BinaryField32b::new(round_constants[0][round_i]));
		for z in 0..1 << log_size {
			add_rc_32b[z] = state_in_u32[0][z] + partial_round_const_32b[z];

			s_box_out_32b[z] = add_rc_32b[z].pow(7);

			let mut input_mds = [B32::ZERO; STATE_SIZE];
			input_mds[0] = s_box_out_32b[z];

			for i in 1..STATE_SIZE {
				input_mds[i] = state_in_u32[i][z];
			}

			for i in 0..STATE_SIZE {
				let mut mds_out_curr = B32::ZERO;

				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_PARTIAL[i][j] as u32) * input_mds[j];
				}
				mds_out_32b[i][z] = mds_out_curr;
			}
		}
	}

	// zero check constraints
	builder.assert_zero(format!("x7_0_partial"), [add_rc, s_box_out], x7_constraint_expr()?);

	Ok(mds_out)
}

#[cfg(test)]
mod tests {
	use binius_core::oracle::OracleId;
	use binius_field::BinaryField32b;

	use super::permutation;
	use crate::{
		builder::test_utils::test_circuit,
		hades::poseidonb_x7_32_768::STATE_SIZE,
		unconstrained::unconstrained,
	};
	#[test]
	fn test_poseidonb() {
		test_circuit(|builder| {
			let log_size = 8;
			let state_in: [OracleId; STATE_SIZE] = std::array::from_fn(|i| {
				unconstrained::<BinaryField32b>(builder, format!("p_in[{i}]"), log_size).unwrap()
			});
			let _state_out = permutation(builder, log_size, state_in).unwrap();
			Ok(vec![])
		})
		.unwrap();
	}
}
