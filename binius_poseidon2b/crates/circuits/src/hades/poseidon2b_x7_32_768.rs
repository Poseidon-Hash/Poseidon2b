// Copyright 2024-2025 Irreducible Inc.

//! Example of a Binius SNARK that proves execution of Poseidon2b permutations.

use std::array;

use anyhow::Result;
use binius_core::{oracle::OracleId, transparent::constant::Constant};
use binius_field::{BinaryField32b, Field, PackedField, TowerField};
use binius_math::{ArithCircuit, ArithExpr};

use crate::builder::{ConstraintSystemBuilder, types::F};

type B32 = BinaryField32b;
const P_ROUNDS: usize = 15;
const F_ROUNDS: usize = 10;
const N_ROUNDS: usize = F_ROUNDS + P_ROUNDS;

const STATE_SIZE: usize = 24;

fn plain_permutation(state: &mut [BinaryField32b; STATE_SIZE], n_rounds: usize) {
	// initial mds matrix mult
	let mds_input = state.clone();
	for i in 0..state.len() {
		// mds matrix mult
		let mut mds_out_curr = B32::ZERO;
		for j in 0..STATE_SIZE {
			mds_out_curr += BinaryField32b::new(MDS_FULL[i][j] as u32) * mds_input[j];
		}
		state[i] = mds_out_curr;
	}

	//full and partial rounds
	for r in 0..n_rounds {
		if r < F_ROUNDS / 2 || r >= F_ROUNDS / 2 + P_ROUNDS {
			//  Full (external) rounds
			for i in 0..state.len() {
				//rc add
				state[i] = state[i] + BinaryField32b::new(RC[i][r]);
			}
			for i in 0..state.len() {
				//sbox
				state[i] = state[i].pow(7);
			}
			let mds_input = state.clone();
			for i in 0..state.len() {
				// mds matrix mult
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_FULL[i][j] as u32) * mds_input[j];
				}
				state[i] = mds_out_curr;
			}

		} else {
			//  Partial (internal) rounds
			//rc add
			state[0] = state[0] + BinaryField32b::new(RC[0][r]);
			//sbox
			state[0] = state[0].pow(7);
			// mds matrix mult
			let mds_input = state.clone();
			for i in 0..state.len() {
				// mds matrix mult
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_PARTIAL[i][j] as u32) * mds_input[j];
				}
				state[i] = mds_out_curr;
			}
		}
	}
}

pub fn permutation(
	builder: &mut ConstraintSystemBuilder,
	log_size: usize,
	p_in: [OracleId; STATE_SIZE],
) -> Result<[OracleId; STATE_SIZE]> {
	println!("Number of rounds: {}", F_ROUNDS + P_ROUNDS);
	let round_0_input: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("mds_out_full_{}", row),
				log_size,
				MDS_FULL[row]
					.iter()
					.enumerate()
					.map(|(i, &elem)| (p_in[i], F::from(BinaryField32b::from(elem as u32)))),
			)
			.unwrap()
	});

	if let Some(witness) = builder.witness() {
		let perm_in_data_owned: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(p_in[i]))?;
		let perm_in_data: [_; STATE_SIZE] = perm_in_data_owned.map(|elem| elem.as_slice::<B32>());
		let mut round_0_input_data: [_; STATE_SIZE] =
			round_0_input.map(|id| witness.new_column::<B32>(id));
		let round_0_input_32b = round_0_input_data
			.each_mut()
			.map(|elem| elem.as_mut_slice::<B32>());

		for z in 0..1 << log_size {
			for i in 0..STATE_SIZE {
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_FULL[i][j] as u32) * perm_in_data[j][z];
				}
				round_0_input_32b[i][z] = mds_out_curr;
			}
		}
	}

	let full_0_out = (0..F_ROUNDS / 2).try_fold(round_0_input, |state, round_i| {
		full_round(builder, log_size, round_i, state, RC)
	})?;

	let partial_out = (F_ROUNDS / 2..(F_ROUNDS / 2 + P_ROUNDS))
		.try_fold(full_0_out, |state, round_i| {
			partial_round(builder, log_size, round_i, state, RC)
		})?;

	let perm_out = (F_ROUNDS / 2 + P_ROUNDS..N_ROUNDS)
		.try_fold(partial_out, |state, round_i| {
			full_round(builder, log_size, round_i, state, RC)
		})?;

	#[cfg(debug_assertions)]
	if let Some(witness) = builder.witness() {
		let p_in_data: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(p_in[i])).unwrap();
		let p_in_32b: [_; STATE_SIZE] = p_in_data.map(|elem| elem.as_slice::<B32>());
		let p_out_data: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(perm_out[i])).unwrap();
		let p_out_32b: [_; STATE_SIZE] = p_out_data.map(|elem| elem.as_slice::<B32>());
		for z in 0..1 << log_size {
			let expected_out: [B32; STATE_SIZE] = array::from_fn(|s| p_out_32b[s][z]);
			let mut state_in: [BinaryField32b; STATE_SIZE] =
				std::array::from_fn(|i| p_in_32b[i][z]);
			plain_permutation(&mut state_in, N_ROUNDS);
			assert_eq!(state_in, expected_out);
		}
	}
	Ok(perm_out)
}

#[rustfmt::skip]
const RC: [[u32; N_ROUNDS]; STATE_SIZE] = [
[0x60518b, 0x7c43ef, 0x6899d, 0x4b4c38, 0x637648, 0x37f5dc, 0x69efaa, 0x77fbea, 0x427745, 0x415567, 0x220478, 0xffce8, 0x13e205, 0x2bd79f, 0x50f4a9, 0x5bfa50, 0xae44a, 0x261059, 0x6bf158, 0x1957dd, 0xf2eea, 0x756bb1, 0x5b5b8, 0x183d53, 0x6230fa, ],
[0x10542e, 0xdc135, 0x34ca56, 0x1a3baa, 0x39118a, 0x1c1876, 0x6fb5bb, 0x31cc18, 0x75e620, 0x5c6427, 0x28428e, 0x2ccfe4, 0x5a646c, 0x6ec565, 0x4e06d1, 0x75a94f, 0x22963a, 0x409bc1, 0x4db5fe, 0x716775, 0x596df, 0xfc0f, 0x605613, 0x48a7a5, 0x3bea94, ],
[0x374541, 0x72b9a0, 0x6f43e5, 0x23c27c, 0x49889b, 0x20d028, 0x65635b, 0x48440d, 0x6743c6, 0x763c4a, 0x2aaa63, 0x4d4bb9, 0x37ed28, 0x20b761, 0x592c79, 0x90d6c, 0x45a486, 0x17d573, 0x2cbbb0, 0x2ccda5, 0x54b287, 0x2926d5, 0x179fea, 0x536c70, 0x1391d4, ],
[0x5b04d8, 0x97131, 0x416cc7, 0x214b07, 0x7dd71d, 0x6cf4c8, 0x61bc2e, 0x37c561, 0x5dfeed, 0x38800a, 0x5d274b, 0x2e7a1f, 0x541329, 0x517095, 0x10ab25, 0x2fecc2, 0x5c7188, 0x1a94e2, 0x32ff9, 0x1836f2, 0x6d3258, 0x2134e4, 0x3f6864, 0x36f37c, 0x36627c, ],
[0x729e54, 0x31054a, 0x5cf616, 0x36f40e, 0x579042, 0x115314, 0x75c5c9, 0x2309f8, 0x3eea67, 0x6aaf62, 0x3faa04, 0x33a555, 0x6f9e11, 0x74dad8, 0x5b20a4, 0x5d1408, 0x26b0ad, 0x70a29e, 0x7edd0c, 0xd3529, 0x70adc3, 0x2240ab, 0x7f1ea0, 0x686a02, 0x58c434, ],
[0x2efa79, 0x2b534e, 0x2f5747, 0x4b459a, 0x7d8dd9, 0x4f4087, 0x29102e, 0x15c6d5, 0x7a3599, 0x4e5bcb, 0x172fb4, 0x505e, 0x7a96ca, 0x303183, 0x4b6b0d, 0x13e1e, 0x167700, 0x719f5c, 0x4b2ac7, 0x30ea53, 0x33f11d, 0x795ac, 0x3307fc, 0x5cbf21, 0x3f2a7c, ],
[0x1d0794, 0x52ba27, 0xa8d86, 0x64b6bf, 0x4c374, 0x74a8c8, 0x501c6f, 0x7b42c3, 0x41e9c7, 0x1a5eaf, 0x74597f, 0x124b3b, 0x3504f, 0x148287, 0x2346fd, 0x2f57c2, 0x6008b2, 0x70c8ac, 0x1d6668, 0x6fa0d8, 0x3d666c, 0x736606, 0x5fe0f, 0x39777b, 0x5322dd, ],
[0x44dec5, 0x76a353, 0x1674ac, 0x77b967, 0x368579, 0x425605, 0x677057, 0x787801, 0x54a99a, 0x3d4a59, 0x1f576a, 0x6a5b8a, 0x6b1e0e, 0x40a66, 0x31f60e, 0x6fa1a3, 0x20d9b0, 0x79a8bd, 0x700ae0, 0x409bf, 0x57ffaa, 0x515f71, 0x4c82b1, 0x2b9e61, 0x3cd2bd, ],
[0x406a2e, 0x445338, 0x3b87c8, 0x3b81da, 0x654eb, 0x24f137, 0x379785, 0x76f95, 0x574965, 0x67160b, 0x490b5c, 0x2a75d8, 0x2f939c, 0x7ab081, 0x2e11fb, 0x26b33e, 0x6f9f63, 0x6269ee, 0x55b743, 0x293d34, 0x544bbb, 0x1e70d3, 0x45339d, 0x70092c, 0x55d963, ],
[0x5a8fb, 0x2eeee5, 0x633df8, 0xea8b8, 0x2af5b0, 0x57ebaf, 0x63655d, 0x6e5739, 0x650599, 0x1222ad, 0x33985d, 0x2a507b, 0x1f5706, 0x45defe, 0x45ff07, 0x73be3, 0x128d72, 0x482d03, 0x130d0e, 0x274cc1, 0x49776e, 0x75dbe1, 0x6eb869, 0x38a646, 0x4e699b, ],
[0x55a890, 0x128e75, 0x2e6488, 0x7c8481, 0x46253d, 0x65c87b, 0x211904, 0x4ebbfe, 0x79a922, 0x24458c, 0x50502e, 0x64f42f, 0x206a48, 0x1d046b, 0x775a39, 0x32025, 0x5649e3, 0x5c3228, 0x55d380, 0x242bcf, 0x16d608, 0x690726, 0x4bc59f, 0x4c0807, 0x523405, ],
[0x54890b, 0x197deb, 0x966c1, 0x478dc8, 0x348d01, 0x3e7c23, 0xf7880, 0x591916, 0xa48fb, 0x28c37a, 0x1e1a39, 0x6a30be, 0x6bdd16, 0x3a1b2a, 0x30722f, 0x19d036, 0x4759a, 0x4b60aa, 0x22ebd9, 0x1e3788, 0x58e3b7, 0x7603b1, 0x64f8e1, 0x7d3e4, 0x5d175, ],
[0x7f583e, 0x3615bc, 0x673f24, 0x35ee72, 0x74568e, 0x3f392b, 0x53d8e9, 0x27794a, 0x3432d1, 0x187c7a, 0x1313d8, 0x7e085a, 0x294cc3, 0x2635bd, 0x116b35, 0x2e0cca, 0x26bb08, 0x84425, 0x11356a, 0x459848, 0x3cc1c5, 0x2c672a, 0x7a16c, 0x730b56, 0x550413, ],
[0x59bbc7, 0x5302a8, 0x1f528c, 0x4d55aa, 0x78b38b, 0x488251, 0x47bb7d, 0x39fc14, 0x5dab8e, 0x9294, 0x35fb8d, 0x532f, 0x3de57c, 0x24436e, 0x53bf99, 0x680de, 0x752e41, 0x58926f, 0x7f4df2, 0x17c617, 0x778d95, 0x246102, 0x5cf8fc, 0x26e31c, 0x22539a, ],
[0x3569c5, 0x2bd282, 0x4b15bc, 0x4a1ff7, 0x11e9f4, 0x21915b, 0x31bc9a, 0x306fd4, 0xa687a, 0x7abbf0, 0x501c73, 0x4f1a55, 0x3c3e44, 0x3b1c51, 0x77a579, 0x8b5a2, 0x356585, 0x561468, 0x2817f4, 0x4aaae8, 0x197f98, 0x5e481f, 0x75713c, 0x2e24c9, 0x6d5a3d, ],
[0x3cd53b, 0x1afea1, 0x8f64a, 0x4a1d51, 0x5c7398, 0x561526, 0x6aac12, 0x10d839, 0x1092d0, 0x3dad89, 0x58f6aa, 0x735372, 0x43b2e0, 0x698731, 0x1214da, 0x66c9c1, 0x53a449, 0x5c0baf, 0x5a12d6, 0xa27e3, 0x57ef62, 0x281e24, 0x34ec86, 0x4ece40, 0x7d9746, ],
[0x4f0f6f, 0x7e8b61, 0x681cf7, 0x32003, 0x1b180, 0x1a95c7, 0x7f3762, 0x50251f, 0x195421, 0x33cc18, 0x1c5e04, 0x128b16, 0x2ccd52, 0x3a8aad, 0x5f5941, 0x523a0f, 0x28f75f, 0x2e902f, 0x56af37, 0x555330, 0x329321, 0x212d68, 0xa42e0, 0x5693, 0x77b9af, ],
[0x21157c, 0x64944d, 0x38093f, 0xdfaaf, 0x589a93, 0x8b50e, 0x55681b, 0x774e4, 0x75d75d, 0x40034, 0x23006, 0xc634e, 0x35bcbb, 0x5567ed, 0x117b4e, 0x27cd78, 0x1e49b6, 0x4a5fc6, 0x728848, 0x5238dd, 0xb770b, 0x74e64e, 0x3ca0ac, 0x494668, 0x4de0d6, ],
[0x55137a, 0x2e355d, 0x49b266, 0x5a268d, 0x67d38f, 0x1a342c, 0x5d748d, 0xaa350, 0x41d866, 0x6dff11, 0x4ae378, 0x6feb0f, 0x1672b6, 0x7afed6, 0x175757, 0x204b0a, 0x363bb7, 0x6d4100, 0xe7088, 0x468744, 0x5210c5, 0x1fe248, 0x3cc1b7, 0x3bce01, 0x2b1f50, ],
[0x3f7570, 0x36adf9, 0x4ea179, 0x7878ed, 0x93a09, 0x72ccbb, 0x190b21, 0x67a1bb, 0x640358, 0x305c0b, 0x77f6f7, 0x1267da, 0x2cab91, 0x615ae9, 0x294d9d, 0x9b7d, 0x1eabac, 0x5eb4d2, 0x585e4f, 0xfd13d, 0x3b77c4, 0x141fee, 0x48196a, 0x2897d1, 0x56251a, ],
[0x18f931, 0x4a90d6, 0x3c24a9, 0xd34ea, 0x771ab, 0x507fa7, 0x250d49, 0x6b10a5, 0x5472ec, 0x370c22, 0x36cfd9, 0x55de3e, 0x4618b, 0x251f01, 0xe6ecb, 0x7143d5, 0x6898bb, 0x27994c, 0x3cc895, 0x4a14df, 0x30b3c7, 0x5634f2, 0x7f4bd2, 0x5819b2, 0x3775db, ],
[0x5a69b4, 0x3ff5d1, 0x7c2988, 0x48ab1e, 0x4356d7, 0x261810, 0x94372, 0x15c102, 0x6dba4e, 0x68e021, 0x3a1259, 0x65a6dc, 0x27c115, 0x29c2f, 0x26cd95, 0x2c94e0, 0x44bd24, 0x1cc337, 0x6e8435, 0x6c2928, 0x441dd5, 0x11e10e, 0x1b1613, 0x5dd955, 0x6a1dc6, ],
[0x1aa730, 0x3b14c1, 0x515bdb, 0x4dd59, 0x1e4613, 0x6b539b, 0x3b9987, 0x392452, 0x3b1eb4, 0x432203, 0x1ed6ac, 0x3cc88d, 0x23d51e, 0x4fddd3, 0x3a5393, 0x2c7d2f, 0x247bb5, 0x379ab6, 0x1d863c, 0x19a495, 0x2b33a6, 0x12c154, 0x2884eb, 0x2cbba, 0x6ae59a, ],
[0x8fcd8, 0x745341, 0x645b6c, 0x5bd857, 0x21c06b, 0x3a3403, 0x73acab, 0x247c01, 0x2983f8, 0x36b6e7, 0xac105, 0x6977d0, 0x3dbf95, 0x17cb3c, 0x389496, 0x2ebb92, 0x34320, 0x153018, 0x53e235, 0x4d4b1d, 0x13e00, 0x534539, 0x61c0e7, 0xe1cf0, 0x23bdb1, ],
];

#[rustfmt::skip]
const MDS_FULL: [[u32; STATE_SIZE]; STATE_SIZE] =[
[0xa, 0xe, 0x2, 0x6, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3,],
[0x8, 0xc, 0x2, 0x2, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1,],
[0x2, 0x6, 0xa, 0xe, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7,],
[0x2, 0x2, 0x8, 0xc, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6,],
[0x5, 0x7, 0x1, 0x3, 0xa, 0xe, 0x2, 0x6, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3,],
[0x4, 0x6, 0x1, 0x1, 0x8, 0xc, 0x2, 0x2, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1,],
[0x1, 0x3, 0x5, 0x7, 0x2, 0x6, 0xa, 0xe, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7,],
[0x1, 0x1, 0x4, 0x6, 0x2, 0x2, 0x8, 0xc, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6,],
[0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0xa, 0xe, 0x2, 0x6, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3,],
[0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x8, 0xc, 0x2, 0x2, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1,],
[0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x2, 0x6, 0xa, 0xe, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7,],
[0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x2, 0x2, 0x8, 0xc, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6,],
[0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0xa, 0xe, 0x2, 0x6, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3,],
[0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x8, 0xc, 0x2, 0x2, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1,],
[0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x2, 0x6, 0xa, 0xe, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7,],
[0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x2, 0x2, 0x8, 0xc, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6,],
[0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0xa, 0xe, 0x2, 0x6, 0x5, 0x7, 0x1, 0x3,],
[0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x8, 0xc, 0x2, 0x2, 0x4, 0x6, 0x1, 0x1,],
[0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x2, 0x6, 0xa, 0xe, 0x1, 0x3, 0x5, 0x7,],
[0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x2, 0x2, 0x8, 0xc, 0x1, 0x1, 0x4, 0x6,],
[0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0xa, 0xe, 0x2, 0x6,],
[0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x8, 0xc, 0x2, 0x2,],
[0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x1, 0x3, 0x5, 0x7, 0x2, 0x6, 0xa, 0xe,],
[0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x4, 0x6, 0x2, 0x2, 0x8, 0xc],
]; 
#[rustfmt::skip]
const MDS_PARTIAL: [[u32; STATE_SIZE]; STATE_SIZE] = [
[0x881, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x4020, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x8100, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x8020, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1008, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x4008, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x402, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x108, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x4001, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1010, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x30, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1800, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x48, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1020, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x208, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x120, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x8400, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x880, 0x1, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x3, 0x1, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2002, 0x1, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0xa0, 0x1, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1004, 0x1,],
[0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x8200],
];

fn x7_constraint_expr<F: TowerField>() -> Result<ArithCircuit<F>> {
	let x = ArithExpr::Var(0);
	let x7 = ArithExpr::Var(1);

	let input_pow2 = x.clone().pow(2);
	let input_pow4 = input_pow2.clone().pow(2);
	let input_pow6 = input_pow2 * input_pow4;
	let input_pow7 = input_pow6 * x.clone();
	
	Ok((x7.clone() - input_pow7).into())
}

fn full_round(
	builder: &mut ConstraintSystemBuilder,
	log_size: usize,
	round_i: usize,
	state_in: [OracleId; STATE_SIZE],
	round_constants: [[u32; N_ROUNDS]; STATE_SIZE],
) -> Result<[OracleId; STATE_SIZE]>
where {
	builder.push_namespace(format!("full round[{round_i}]"));
	let full_round_consts: [OracleId; STATE_SIZE] = array::from_fn(|i| {
		builder
			.add_transparent(
				format!("full_round_const{}", i),
				Constant::new(log_size, BinaryField32b::new(round_constants[i][round_i])),
			)
			.unwrap()
	});

	let add_rc: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("add_rc_full_{}", row),
				log_size,
				[
					(state_in[row], Field::ONE),
					(full_round_consts[row], Field::ONE),
				],
			)
			.unwrap()
	});

	let s_box_out = builder.add_committed_multiple::<STATE_SIZE>(
		"sbox_out_full",
		log_size,
		BinaryField32b::TOWER_LEVEL,
	);

	let mds_out: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("mds_out_full_{}", row),
				log_size,
				MDS_FULL[row]
					.iter()
					.enumerate()
					.map(|(i, &elem)| (s_box_out[i], F::from(BinaryField32b::new(elem as u32)))),
			)
			.unwrap()
	});

	builder.pop_namespace();

	// Witness gen
	if let Some(witness) = builder.witness() {
		let state_in: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(state_in[i]))?;
		let state_in_u32: [_; STATE_SIZE] = state_in.map(|elem| elem.as_slice::<B32>());

		let mut full_round_consts = full_round_consts.map(|id| witness.new_column::<B32>(id));
		let full_round_consts_32b = full_round_consts
			.each_mut()
			.map(|elem| elem.as_mut_slice::<B32>());

		let mut add_rc = add_rc.map(|id| witness.new_column::<B32>(id));
		let add_rc_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			add_rc.each_mut().map(|elem| elem.as_mut_slice());

		let mut s_box_out = s_box_out.map(|id| witness.new_column::<B32>(id));
		let s_box_out_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			s_box_out.each_mut().map(|elem| elem.as_mut_slice());

		let mut mds_out = mds_out.map(|id| witness.new_column::<B32>(id));
		let mds_out_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			mds_out.each_mut().map(|elem| elem.as_mut_slice());

		// Fill in constants
		for i in 0..STATE_SIZE {
			full_round_consts_32b[i]
				.iter_mut()
				.for_each(|rc| *rc = BinaryField32b::new(round_constants[i][round_i]));
		}

		for z in 0..1 << log_size {
			for i in 0..STATE_SIZE {
				add_rc_32b[i][z] = state_in_u32[i][z] + full_round_consts_32b[i][z];
			}

			for i in 0..STATE_SIZE {
				s_box_out_32b[i][z] = add_rc_32b[i][z].pow(7);
			}

			for i in 0..STATE_SIZE {
				let mut mds_out_curr = B32::ZERO;
				for j in 0..STATE_SIZE {
					mds_out_curr +=
						BinaryField32b::new(MDS_FULL[i][j] as u32) * s_box_out_32b[j][z];
				}
				mds_out_32b[i][z] = mds_out_curr;
			}
		}
	}

	// zero check constraints
	for s in 0..STATE_SIZE {
		builder.assert_zero(format!("x7_{s}"), [add_rc[s], s_box_out[s]], x7_constraint_expr()?);
	}

	Ok(mds_out)
}

fn partial_round(
	builder: &mut ConstraintSystemBuilder,
	log_size: usize,
	round_i: usize,
	state_in: [OracleId; STATE_SIZE],
	round_constants: [[u32; N_ROUNDS]; STATE_SIZE],
) -> Result<[OracleId; STATE_SIZE]>
where {
	builder.push_namespace(format!("round[{round_i}]"));

	let partial_round_const: OracleId = builder
		.add_transparent(
			format!("partial_round_const{}", 0),
			Constant::new(log_size, BinaryField32b::new(round_constants[0][round_i])),
		)
		.unwrap();

	let add_rc: OracleId = builder
		.add_linear_combination(
			format!("add_rc_partial_0"),
			log_size,
			[(state_in[0], Field::ONE), (partial_round_const, Field::ONE)],
		)
		.unwrap();

	let s_box_out: OracleId =
		builder.add_committed("sbox_out_partial", log_size, BinaryField32b::TOWER_LEVEL);

	let mds_out: [OracleId; STATE_SIZE] = array::from_fn(|row| {
		builder
			.add_linear_combination(
				format!("mds_out_partial_{}", row),
				log_size,
				MDS_PARTIAL[row].iter().enumerate().map(|(i, &elem)| {
					if i == 0 {
						(s_box_out, F::from(BinaryField32b::new(elem as u32)))
					} else {
						(state_in[i], F::from(BinaryField32b::new(elem as u32)))
					}
				}),
			)
			.unwrap()
	});

	builder.pop_namespace();

	type B32 = BinaryField32b;

	// Witness gen
	if let Some(witness) = builder.witness() {
		let state_in: [_; STATE_SIZE] =
			array_util::try_from_fn(|i| witness.get::<B32>(state_in[i]))?;
		let state_in_u32: [_; STATE_SIZE] = state_in.map(|elem| elem.as_slice::<B32>());
		let mut partial_round_const = witness.new_column::<B32>(partial_round_const);
		let partial_round_const_32b = partial_round_const.as_mut_slice::<B32>();

		let mut add_rc = witness.new_column::<B32>(add_rc);
		let add_rc_32b: &mut [BinaryField32b] = add_rc.as_mut_slice();

		let mut s_box_out = witness.new_column::<B32>(s_box_out);
		let s_box_out_32b: &mut [BinaryField32b] = s_box_out.as_mut_slice();

		let mut mds_out = mds_out.map(|id| witness.new_column::<B32>(id));
		let mds_out_32b: [&mut [BinaryField32b]; STATE_SIZE] =
			mds_out.each_mut().map(|elem| elem.as_mut_slice());

		// Fill in constants
		partial_round_const_32b
			.iter_mut()
			.for_each(|rc| *rc = BinaryField32b::new(round_constants[0][round_i]));
		for z in 0..1 << log_size {
			add_rc_32b[z] = state_in_u32[0][z] + partial_round_const_32b[z];

			s_box_out_32b[z] = add_rc_32b[z].pow(7);

			let mut input_mds = [B32::ZERO; STATE_SIZE];
			input_mds[0] = s_box_out_32b[z];

			for i in 1..STATE_SIZE {
				input_mds[i] = state_in_u32[i][z];
			}

			for i in 0..STATE_SIZE {
				let mut mds_out_curr = B32::ZERO;

				for j in 0..STATE_SIZE {
					mds_out_curr += BinaryField32b::new(MDS_PARTIAL[i][j] as u32) * input_mds[j];
				}
				mds_out_32b[i][z] = mds_out_curr;
			}
		}
	}

	// zero check constraints
	builder.assert_zero(format!("x7_0_partial"), [add_rc, s_box_out], x7_constraint_expr()?);

	Ok(mds_out)
}

#[cfg(test)]
mod tests {
	use binius_core::oracle::OracleId;
	use binius_field::BinaryField32b;

	use super::permutation;
	use crate::{
		builder::test_utils::test_circuit,
		hades::poseidon2b_x7_32_768::STATE_SIZE,
		unconstrained::unconstrained,
	};
	#[test]
	fn test_poseidon2b() {
		test_circuit(|builder| {
			let log_size = 8;
			let state_in: [OracleId; STATE_SIZE] = std::array::from_fn(|i| {
				unconstrained::<BinaryField32b>(builder, format!("p_in[{i}]"), log_size).unwrap()
			});
			let _state_out = permutation(builder, log_size, state_in).unwrap();
			Ok(vec![])
		})
		.unwrap();
	}
}
